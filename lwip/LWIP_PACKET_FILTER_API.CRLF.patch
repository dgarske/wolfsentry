diff --git a/src/core/ipv4/icmp.c b/src/core/ipv4/icmp.c
index f35ff4b5..ae368bee 100644
--- a/src/core/ipv4/icmp.c
+++ b/src/core/ipv4/icmp.c
@@ -102,6 +102,14 @@ icmp_input(struct pbuf *p, struct netif *inp)
     goto lenerr;
   }
 
+#if LWIP_PACKET_FILTER_API
+  if (icmp_filter_dispatch_incoming(FILT_RECEIVING, inp, (struct icmp_hdr *)p->payload) != ERR_OK) {
+    LWIP_DEBUGF(IP_DEBUG, ("icmp_input: icmp_filter_dispatch_incoming rejected packet.\n"));
+    pbuf_free(p);
+    return;
+  }
+#endif
+
   type = *((u8_t *)p->payload);
 #ifdef LWIP_DEBUG
   code = *(((u8_t *)p->payload) + 1);
@@ -232,6 +240,13 @@ icmp_input(struct pbuf *p, struct netif *inp)
         iecho->chksum = 0;
 #endif /* CHECKSUM_GEN_ICMP */
 
+#if LWIP_PACKET_FILTER_API
+        if (icmp_filter_dispatch_outgoing(FILT_SENDING, inp, &iphdr->src, &iphdr->dest, iecho->type, (const struct icmp_hdr *)iecho) != ERR_OK) {
+          LWIP_DEBUGF(IP_DEBUG, ("icmp_input: icmp_filter_dispatch_outgoing rejected reply packet.\n"));
+          break;
+        }
+#endif
+
         /* Set the correct TTL and recalculate the header checksum. */
         IPH_TTL_SET(iphdr, ICMP_TTL);
         IPH_CHKSUM_SET(iphdr, 0);
@@ -391,6 +406,22 @@ icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
 #else
   netif = ip4_route(&iphdr_src);
 #endif
+
+#if LWIP_PACKET_FILTER_API
+  /* packet filter deferred to here so that netif is available.  as a bonus,
+   * have an icmphdr to pass to the handler.
+   *
+   * src and dest are swapped because iphdr is for the incoming packet, which
+   * we're turning around.
+   */
+  if (netif != NULL) {
+    if (icmp_filter_dispatch_outgoing(FILT_SENDING, netif, &iphdr->dest, &iphdr->src, type, icmphdr) != ERR_OK) {
+      LWIP_DEBUGF(IP_DEBUG, ("icmp_send_response: icmp_filter_dispatch_outgoing rejected packet.\n"));
+      netif = NULL;
+    }
+  }
+#endif
+
   if (netif != NULL) {
     /* calculate checksum */
     icmphdr->chksum = 0;
@@ -405,4 +436,84 @@ icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
   pbuf_free(q);
 }
 
+#if LWIP_PACKET_FILTER_API
+
+static void *filter_arg = 0;
+static icmp_filter_fn filter_cb = NULL;
+static packet_filter_event_mask_t filter_reason_mask = 0;
+
+void
+icmp_filter_arg(void *arg)
+{
+  filter_arg = arg;
+}
+
+void
+icmp_filter_mask(packet_filter_event_mask_t mask)
+{
+  filter_reason_mask = mask;
+}
+
+void icmp_filter(icmp_filter_fn filter) {
+  filter_cb = filter;
+}
+
+err_t icmp_filter_dispatch_incoming(packet_filter_event_t reason, const struct netif *netif, const struct icmp_hdr *hdr) {
+  struct packet_filter_event event;
+  err_t ret;
+
+  if (! ((1U << reason) & filter_reason_mask))
+    return ERR_OK;
+  if (hdr == NULL)
+    return ERR_OK;
+  if (filter_cb == NULL)
+    return ERR_OK;
+  LWIP_ASSERT_CORE_LOCKED();
+
+  if (packet_filter_lock)
+    return ERR_OK;
+  else
+    packet_filter_lock = 1;
+
+  event.reason = reason;
+  event.netif = netif;
+  event.packet_hdr.icmp_hdr = hdr;
+  ret = filter_cb(filter_arg, &event,
+                   ip4_current_dest_addr(), ip4_current_src_addr(), hdr->type);
+
+  packet_filter_lock = 0;
+
+  return ret;
+}
+
+err_t icmp_filter_dispatch_outgoing(packet_filter_event_t reason, const struct netif *netif, const ip4_addr_p_t *laddr, const ip4_addr_p_t *raddr, u8_t icmp4_type, const struct icmp_hdr *hdr) {
+  struct packet_filter_event event;
+  ip4_addr_t laddr_aligned, raddr_aligned;
+  err_t ret;
+
+  if (! ((1U << reason) & filter_reason_mask))
+    return ERR_OK;
+  if (filter_cb == NULL)
+    return ERR_OK;
+  LWIP_ASSERT_CORE_LOCKED();
+
+  if (packet_filter_lock)
+    return ERR_OK;
+  else
+    packet_filter_lock = 1;
+
+  event.reason = reason;
+  event.netif = netif;
+  event.packet_hdr.icmp_hdr = hdr;
+  memcpy(&laddr_aligned, laddr, sizeof laddr_aligned);
+  memcpy(&raddr_aligned, raddr, sizeof raddr_aligned);
+  ret = filter_cb(filter_arg, &event, &laddr_aligned, &raddr_aligned, icmp4_type);
+
+  packet_filter_lock = 0;
+
+  return ret;
+}
+
+#endif /* LWIP_PACKET_FILTER_API */
+
 #endif /* LWIP_IPV4 && LWIP_ICMP */
diff --git a/src/core/ipv4/ip4.c b/src/core/ipv4/ip4.c
index e044bff2..7c147105 100644
--- a/src/core/ipv4/ip4.c
+++ b/src/core/ipv4/ip4.c
@@ -648,6 +648,17 @@ ip4_input(struct pbuf *p, struct netif *inp)
     }
   }
 
+#if LWIP_PACKET_FILTER_API
+  if (ip4_filter_dispatch_incoming(FILT_RECEIVING, inp, p) != ERR_OK) {
+    LWIP_DEBUGF(IP_DEBUG, ("ip4_input: ip4_filter_dispatch_incoming rejected packet.\n"));
+    /* free (drop) packet pbufs */
+    pbuf_free(p);
+    IP_STATS_INC(ip.drop);
+    MIB2_STATS_INC(mib2.ipindiscards);
+    return ERR_OK;
+  }
+#endif
+
   /* packet not for us? */
   if (netif == NULL) {
     /* packet not for us, route or discard */
@@ -1009,6 +1020,18 @@ ip4_output_if_opt_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *d
     dest = &dest_addr;
   }
 
+#if LWIP_PACKET_FILTER_API
+  {
+    err_t ret = ip4_filter_dispatch_outgoing(FILT_SENDING, netif, src, dest, p);
+    if (ret != ERR_OK) {
+      LWIP_DEBUGF(IP_DEBUG, ("ip4_output: ip4_filter_dispatch_outgoing rejected packet\n"));
+      MIB2_STATS_INC(mib2.ipoutdiscards);
+      IP_STATS_INC(ip.drop);
+      return ret;
+    }
+  }
+#endif /* LWIP_PACKET_FILTER_API */
+
   IP_STATS_INC(ip.xmit);
 
   LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: %c%c%"U16_F"\n", netif->name[0], netif->name[1], (u16_t)netif->num));
@@ -1163,4 +1186,81 @@ ip4_debug_print(struct pbuf *p)
 }
 #endif /* IP_DEBUG */
 
+#if LWIP_PACKET_FILTER_API
+
+static void *filter_arg = 0;
+static ip4_filter_fn filter_cb = NULL;
+static packet_filter_event_mask_t filter_reason_mask = 0;
+
+void
+ip4_filter_arg(void *arg)
+{
+  filter_arg = arg;
+}
+
+void
+ip4_filter_mask(packet_filter_event_mask_t mask)
+{
+  filter_reason_mask = mask;
+}
+
+void ip4_filter(ip4_filter_fn filter) {
+  filter_cb = filter;
+}
+
+err_t ip4_filter_dispatch_incoming(packet_filter_event_t reason, const struct netif *netif, const struct pbuf *p) {
+  struct packet_filter_event event;
+  err_t ret;
+
+  if (! ((1U << reason) & filter_reason_mask))
+    return ERR_OK;
+  if (filter_cb == NULL)
+    return ERR_OK;
+  LWIP_ASSERT_CORE_LOCKED();
+
+  if (packet_filter_lock)
+    return ERR_OK;
+  else
+    packet_filter_lock = 1;
+
+  event.reason = reason;
+  event.netif = netif;
+  event.pcb.raw_p = p;
+  event.packet_hdr.ip4_hdr = (struct ip_hdr *)p->payload;
+  ret = filter_cb(filter_arg, &event,
+                  ip4_current_dest_addr(), ip4_current_src_addr(), ((struct ip_hdr *)p->payload)->_proto);
+
+  packet_filter_lock = 0;
+
+  return ret;
+}
+
+err_t ip4_filter_dispatch_outgoing(packet_filter_event_t reason, const struct netif *netif, const ip4_addr_t *src, const ip4_addr_t *dest, const struct pbuf *p) {
+  struct packet_filter_event event;
+  err_t ret;
+
+  if (! ((1U << reason) & filter_reason_mask))
+    return ERR_OK;
+  if (filter_cb == NULL)
+    return ERR_OK;
+  LWIP_ASSERT_CORE_LOCKED();
+
+  if (packet_filter_lock)
+    return ERR_OK;
+  else
+    packet_filter_lock = 1;
+
+  event.reason = reason;
+  event.netif = netif;
+  event.pcb.raw_p = p;
+  event.packet_hdr.ip4_hdr = (struct ip_hdr *)p->payload;
+  ret = filter_cb(filter_arg, &event, src, dest, ((struct ip_hdr *)p->payload)->_proto);
+
+  packet_filter_lock = 0;
+
+  return ret;
+}
+
+#endif /* LWIP_PACKET_FILTER_API */
+
 #endif /* LWIP_IPV4 */
diff --git a/src/core/ipv6/icmp6.c b/src/core/ipv6/icmp6.c
index ed0bd7b7..4cd0b74d 100644
--- a/src/core/ipv6/icmp6.c
+++ b/src/core/ipv6/icmp6.c
@@ -99,6 +99,14 @@ icmp6_input(struct pbuf *p, struct netif *inp)
 
   icmp6hdr = (struct icmp6_hdr *)p->payload;
 
+#if LWIP_PACKET_FILTER_API
+  if (icmp6_filter_dispatch_incoming(FILT_RECEIVING, inp, icmp6hdr) != ERR_OK) {
+    LWIP_DEBUGF(IP_DEBUG, ("icmp6_input: icmp6_filter_dispatch_incoming rejected packet.\n"));
+    pbuf_free(p);
+    return;
+  }
+#endif
+
 #if CHECKSUM_CHECK_ICMP6
   IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_ICMP6) {
     if (ip6_chksum_pseudo(p, IP6_NEXTH_ICMP6, p->tot_len, ip6_current_src_addr(),
@@ -189,6 +197,15 @@ icmp6_input(struct pbuf *p, struct netif *inp)
     }
 #endif /* CHECKSUM_GEN_ICMP6 */
 
+#if LWIP_PACKET_FILTER_API
+    if (icmp6_filter_dispatch_outgoing(FILT_SENDING, inp, reply_src, ip6_current_src_addr(), ((struct icmp6_echo_hdr *)(r->payload))->type, (const struct icmp6_hdr *)r->payload) != ERR_OK) {
+      LWIP_DEBUGF(IP_DEBUG, ("icmp6_input: icmp6_filter_dispatch_outgoing rejected reply packet.\n"));
+      pbuf_free(p);
+      pbuf_free(r);
+      return;
+    }
+#endif
+
     /* Send reply. */
     ICMP6_STATS_INC(icmp6.xmit);
     ip6_output_if(r, reply_src, ip6_current_src_addr(),
@@ -389,6 +406,13 @@ icmp6_send_response_with_addrs_and_netif(struct pbuf *p, u8_t code, u32_t data,
   struct icmp6_hdr *icmp6hdr;
   u16_t datalen = LWIP_MIN(p->tot_len, LWIP_ICMP6_DATASIZE);
 
+#if LWIP_PACKET_FILTER_API
+  if (icmp6_filter_dispatch_outgoing(FILT_SENDING, netif, reply_src, reply_dest, type, NULL /* icmp6_hdr */) != ERR_OK) {
+    LWIP_DEBUGF(IP_DEBUG, ("icmp6_send_response: icmp6_filter_dispatch_outgoing rejected packet.\n"));
+    return;
+  }
+#endif
+
   /* ICMPv6 header + datalen (as much of the offending packet as possible) */
   q = pbuf_alloc(PBUF_IP, sizeof(struct icmp6_hdr) + datalen,
                  PBUF_RAM);
@@ -422,4 +446,81 @@ icmp6_send_response_with_addrs_and_netif(struct pbuf *p, u8_t code, u32_t data,
   pbuf_free(q);
 }
 
+#if LWIP_PACKET_FILTER_API
+
+static void *filter_arg = 0;
+static icmp6_filter_fn filter_cb = NULL;
+static packet_filter_event_mask_t filter_reason_mask = 0;
+
+void
+icmp6_filter_arg(void *arg)
+{
+  filter_arg = arg;
+}
+
+void
+icmp6_filter_mask(packet_filter_event_mask_t mask)
+{
+  filter_reason_mask = mask;
+}
+
+void icmp6_filter(icmp6_filter_fn filter) {
+  filter_cb = filter;
+}
+
+err_t icmp6_filter_dispatch_incoming(packet_filter_event_t reason, const struct netif *netif, const struct icmp6_hdr *hdr) {
+  struct packet_filter_event event;
+  err_t ret;
+
+  if (! ((1U << reason) & filter_reason_mask))
+    return ERR_OK;
+  if (hdr == NULL)
+    return ERR_OK;
+  if (filter_cb == NULL)
+    return ERR_OK;
+  LWIP_ASSERT_CORE_LOCKED();
+
+  if (packet_filter_lock)
+    return ERR_OK;
+  else
+    packet_filter_lock = 1;
+
+  event.reason = reason;
+  event.netif = netif;
+  event.packet_hdr.icmp6_hdr = hdr;
+  ret = filter_cb(filter_arg, &event,
+                  ip6_current_dest_addr(), ip6_current_src_addr(), hdr->type);
+
+  packet_filter_lock = 0;
+
+  return ret;
+}
+
+err_t icmp6_filter_dispatch_outgoing(packet_filter_event_t reason, const struct netif *netif, const ip6_addr_t *laddr, const ip6_addr_t *raddr, u8_t icmp6_type, const struct icmp6_hdr *hdr) {
+  struct packet_filter_event event;
+  err_t ret;
+
+  if (! ((1U << reason) & filter_reason_mask))
+    return ERR_OK;
+  if (filter_cb == NULL)
+    return ERR_OK;
+  LWIP_ASSERT_CORE_LOCKED();
+
+  if (packet_filter_lock)
+    return ERR_OK;
+  else
+    packet_filter_lock = 1;
+
+  event.reason = reason;
+  event.netif = netif;
+  event.packet_hdr.icmp6_hdr = hdr;
+  ret = filter_cb(filter_arg, &event, laddr, raddr, icmp6_type);
+
+  packet_filter_lock = 0;
+
+  return ret;
+}
+
+#endif /* LWIP_PACKET_FILTER_API */
+
 #endif /* LWIP_ICMP6 && LWIP_IPV6 */
diff --git a/src/core/ipv6/ip6.c b/src/core/ipv6/ip6.c
index 2c25f8ad..29c1f543 100644
--- a/src/core/ipv6/ip6.c
+++ b/src/core/ipv6/ip6.c
@@ -679,6 +679,16 @@ netif_found:
     goto ip6_input_cleanup;
   }
 
+#if LWIP_PACKET_FILTER_API
+  if (ip6_filter_dispatch_incoming(FILT_RECEIVING, inp, p) != ERR_OK) {
+    LWIP_DEBUGF(IP6_DEBUG, ("ip6_input: ip6_filter_dispatch_incoming rejected packet.\n"));
+    /* free (drop) packet pbufs */
+    pbuf_free(p);
+    IP6_STATS_INC(ip6.drop);
+    goto ip6_input_cleanup;
+  }
+#endif
+
   /* packet not for us? */
   if (netif == NULL) {
     /* packet not for us, route or discard */
@@ -1231,6 +1241,17 @@ ip6_output_if_src(struct pbuf *p, const ip6_addr_t *src, const ip6_addr_t *dest,
     dest = &dest_addr;
   }
 
+#if LWIP_PACKET_FILTER_API
+  {
+    err_t ret = ip6_filter_dispatch_outgoing(FILT_SENDING, netif, src, dest, p);
+    if (ret != ERR_OK) {
+      LWIP_DEBUGF(IP_DEBUG, ("ip6_output: ip6_filter_dispatch_outgoing rejected packet\n"));
+      IP6_STATS_INC(ip6.drop);
+      return ret;
+    }
+  }
+#endif /* LWIP_PACKET_FILTER_API */
+
   IP6_STATS_INC(ip6.xmit);
 
   LWIP_DEBUGF(IP6_DEBUG, ("ip6_output_if: %c%c%"U16_F"\n", netif->name[0], netif->name[1], (u16_t)netif->num));
@@ -1492,4 +1513,81 @@ ip6_debug_print(struct pbuf *p)
 }
 #endif /* IP6_DEBUG */
 
+#if LWIP_PACKET_FILTER_API
+
+static void *filter_arg = 0;
+static ip6_filter_fn filter_cb = NULL;
+static packet_filter_event_mask_t filter_reason_mask = 0;
+
+void
+ip6_filter_arg(void *arg)
+{
+  filter_arg = arg;
+}
+
+void
+ip6_filter_mask(packet_filter_event_mask_t mask)
+{
+  filter_reason_mask = mask;
+}
+
+void ip6_filter(ip6_filter_fn filter) {
+  filter_cb = filter;
+}
+
+err_t ip6_filter_dispatch_incoming(packet_filter_event_t reason, const struct netif *netif, const struct pbuf *p) {
+  struct packet_filter_event event;
+  err_t ret;
+
+  if (! ((1U << reason) & filter_reason_mask))
+    return ERR_OK;
+  if (filter_cb == NULL)
+    return ERR_OK;
+  LWIP_ASSERT_CORE_LOCKED();
+
+  if (packet_filter_lock)
+    return ERR_OK;
+  else
+    packet_filter_lock = 1;
+
+  event.reason = reason;
+  event.netif = netif;
+  event.pcb.raw_p = p;
+  event.packet_hdr.ip6_hdr = (struct ip6_hdr *)p->payload;
+  ret = filter_cb(filter_arg, &event,
+                  ip6_current_dest_addr(), ip6_current_src_addr(), IP6H_NEXTH((struct ip6_hdr *)p->payload));
+
+  packet_filter_lock = 0;
+
+  return ret;
+}
+
+err_t ip6_filter_dispatch_outgoing(packet_filter_event_t reason, const struct netif *netif, const ip6_addr_t *src, const ip6_addr_t *dest, const struct pbuf *p) {
+  struct packet_filter_event event;
+  err_t ret;
+
+  if (! ((1U << reason) & filter_reason_mask))
+    return ERR_OK;
+  if (filter_cb == NULL)
+    return ERR_OK;
+  LWIP_ASSERT_CORE_LOCKED();
+
+  if (packet_filter_lock)
+    return ERR_OK;
+  else
+    packet_filter_lock = 1;
+
+  event.reason = reason;
+  event.netif = netif;
+  event.pcb.raw_p = p;
+  event.packet_hdr.ip6_hdr = (struct ip6_hdr *)p->payload;
+  ret = filter_cb(filter_arg, &event, src, dest, IP6H_NEXTH((struct ip6_hdr *)p->payload));
+
+  packet_filter_lock = 0;
+
+  return ret;
+}
+
+#endif /* LWIP_PACKET_FILTER_API */
+
 #endif /* LWIP_IPV6 */
diff --git a/src/core/pbuf.c b/src/core/pbuf.c
index 54a6e0e4..f234aa2f 100644
--- a/src/core/pbuf.c
+++ b/src/core/pbuf.c
@@ -84,6 +84,10 @@
 #include "lwip/inet_chksum.h"
 #endif
 
+#if LWIP_PACKET_FILTER_API
+int packet_filter_lock = 0;
+#endif
+
 #include <string.h>
 
 #define SIZEOF_STRUCT_PBUF        LWIP_MEM_ALIGN_SIZE(sizeof(struct pbuf))
diff --git a/src/core/tcp.c b/src/core/tcp.c
index ea95ffee..d0a1a2d9 100644
--- a/src/core/tcp.c
+++ b/src/core/tcp.c
@@ -367,6 +367,9 @@ tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
         /* prevent using a deallocated pcb: free it from tcp_input later */
         tcp_trigger_input_pcb_close();
       } else {
+#if LWIP_PACKET_FILTER_API
+        (void)tcp_filter_dispatch_outgoing(FILT_CLOSED, pcb, NULL /* force netif lookup */);
+#endif
         tcp_free(pcb);
       }
       return ERR_OK;
@@ -384,6 +387,9 @@ tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
        * or for a pcb that has been used and then entered the CLOSED state
        * is erroneous, but this should never happen as the pcb has in those cases
        * been freed, and so any remaining handles are bogus. */
+#if LWIP_PACKET_FILTER_API
+      (void)tcp_filter_dispatch_outgoing(FILT_CLOSED, pcb, NULL /* force netif lookup */);
+#endif
       if (pcb->local_port != 0) {
         TCP_RMV(&tcp_bound_pcbs, pcb);
       }
@@ -392,9 +398,15 @@ tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
     case LISTEN:
       tcp_listen_closed(pcb);
       tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
+#if LWIP_PACKET_FILTER_API
+      (void)tcp_filter_dispatch_outgoing(FILT_STOP_LISTENING, pcb, NULL);
+#endif
       tcp_free_listen(pcb);
       break;
     case SYN_SENT:
+#if LWIP_PACKET_FILTER_API
+      (void)tcp_filter_dispatch_outgoing(FILT_CLOSED, pcb, NULL /* force netif lookup */);
+#endif
       TCP_PCB_REMOVE_ACTIVE(pcb);
       tcp_free(pcb);
       MIB2_STATS_INC(mib2.tcpattemptfails);
@@ -579,6 +591,9 @@ tcp_abandon(struct tcp_pcb *pcb, int reset)
      are in an active state, call the receive function associated with
      the PCB with a NULL argument, and send an RST to the remote end. */
   if (pcb->state == TIME_WAIT) {
+#if LWIP_PACKET_FILTER_API
+    (void)tcp_filter_dispatch_outgoing(FILT_CLOSED, pcb, NULL /* force netif lookup */);
+#endif
     tcp_pcb_remove(&tcp_tw_pcbs, pcb);
     tcp_free(pcb);
   } else {
@@ -618,6 +633,9 @@ tcp_abandon(struct tcp_pcb *pcb, int reset)
       tcp_rst(pcb, seqno, ackno, &pcb->local_ip, &pcb->remote_ip, local_port, pcb->remote_port);
     }
     last_state = pcb->state;
+#if LWIP_PACKET_FILTER_API
+    (void)tcp_filter_dispatch_outgoing(FILT_CLOSED, pcb, NULL /* force netif lookup */);
+#endif
     tcp_free(pcb);
     TCP_EVENT_ERR(last_state, errf, errf_arg, ERR_ABRT);
   }
@@ -745,6 +763,9 @@ tcp_bind(struct tcp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
     ip_addr_set(&pcb->local_ip, ipaddr);
   }
   pcb->local_port = port;
+
+  TCP_FILTER_ASSERT_INCOMING(FILT_BINDING, pcb, NULL, NULL);
+
   TCP_REG(&tcp_bound_pcbs, pcb);
   LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
   return ERR_OK;
@@ -880,6 +901,15 @@ tcp_listen_with_backlog_and_err(struct tcp_pcb *pcb, u8_t backlog, err_t *err)
     }
   }
 #endif /* SO_REUSE */
+
+#if LWIP_PACKET_FILTER_API
+  res = tcp_filter_dispatch_incoming(FILT_LISTENING, pcb, NULL, NULL);
+  if (res != 0) {
+    LWIP_DEBUGF(IP_DEBUG, ("tcp_listen: tcp_filter_dispatch_incoming rejected listening.\n"));
+    goto done;
+  }
+#endif
+
   lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
   if (lpcb == NULL) {
     res = ERR_MEM;
@@ -1107,6 +1137,8 @@ tcp_connect(struct tcp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port,
     ip_addr_copy(pcb->local_ip, *local_ip);
   }
 
+  TCP_FILTER_ASSERT_OUTGOING(FILT_CONNECTING, pcb, netif);
+
 #if LWIP_IPV6 && LWIP_IPV6_SCOPES
   /* If the given IP address should have a zone but doesn't, assign one now.
    * Given that we already have the target netif, this is easy and cheap. */
@@ -1387,6 +1419,9 @@ tcp_slowtmr_start:
 #endif /* LWIP_CALLBACK_API */
       void *err_arg;
       enum tcp_state last_state;
+#if LWIP_PACKET_FILTER_API
+      (void)tcp_filter_dispatch_outgoing(FILT_CLOSED, pcb, NULL /* force netif lookup */);
+#endif
       tcp_pcb_purge(pcb);
       /* Remove PCB from tcp_active_pcbs list. */
       if (prev != NULL) {
@@ -1453,6 +1488,9 @@ tcp_slowtmr_start:
     /* If the PCB should be removed, do it. */
     if (pcb_remove) {
       struct tcp_pcb *pcb2;
+#if LWIP_PACKET_FILTER_API
+      (void)tcp_filter_dispatch_outgoing(FILT_CLOSED, pcb, NULL /* force netif lookup */);
+#endif
       tcp_pcb_purge(pcb);
       /* Remove PCB from tcp_tw_pcbs list. */
       if (prev != NULL) {
@@ -2693,4 +2731,99 @@ tcp_ext_arg_invoke_callbacks_passive_open(struct tcp_pcb_listen *lpcb, struct tc
 }
 #endif /* LWIP_TCP_PCB_NUM_EXT_ARGS */
 
+#if LWIP_PACKET_FILTER_API
+
+static void *filter_arg = 0;
+static tcp_filter_fn filter_cb = NULL;
+static packet_filter_event_mask_t filter_reason_mask = 0;
+
+void
+tcp_filter_arg(void *arg)
+{
+  filter_arg = arg;
+}
+
+void
+tcp_filter_mask(packet_filter_event_mask_t mask)
+{
+  filter_reason_mask = mask;
+}
+
+void tcp_filter(tcp_filter_fn cb) {
+  filter_cb = cb;
+}
+
+err_t tcp_filter_dispatch_incoming(packet_filter_event_t reason, struct tcp_pcb *pcb, struct netif *netif, struct tcp_hdr *hdr) {
+  struct packet_filter_event event;
+  err_t ret;
+
+  if (! ((1U << reason) & filter_reason_mask))
+    return ERR_OK;
+  if (filter_cb == NULL)
+    return ERR_OK;
+  LWIP_ASSERT_CORE_LOCKED();
+
+  if (packet_filter_lock)
+    return ERR_OK;
+  else
+    packet_filter_lock = 1;
+
+  if ((netif == NULL) && (pcb != NULL))
+    netif = netif_get_by_index(pcb->netif_idx);
+  event.reason = reason;
+  event.netif = netif;
+  event.pcb.tcp_pcb = pcb;
+  event.packet_hdr.tcp_hdr = hdr;
+  if (hdr != NULL) {
+    ret = filter_cb(filter_arg, &event,
+                    ip_current_dest_addr(), hdr->dest, ip_current_src_addr(), hdr->src);
+  } else if (pcb != NULL) {
+    LWIP_ASSERT("invalid socket state for tcp_filter_dispatch_incoming", pcb->state != LISTEN);
+    if (pcb->state == LISTEN)
+      ret = filter_cb(filter_arg, &event,
+                      &pcb->local_ip, pcb->local_port, NULL /* raddr */, 0 /* remote_port */);
+    else
+      ret = filter_cb(filter_arg, &event,
+                      &pcb->local_ip, pcb->local_port, &pcb->remote_ip, pcb->remote_port);
+  } else
+    ret = ERR_OK;
+
+  packet_filter_lock = 0;
+
+  return ret;
+}
+
+err_t tcp_filter_dispatch_outgoing(packet_filter_event_t reason, struct tcp_pcb *pcb, struct netif *netif) {
+  if (! ((1U << reason) & filter_reason_mask))
+    return ERR_OK;
+  if (filter_cb == NULL)
+    return ERR_OK;
+  LWIP_ASSERT_CORE_LOCKED();
+
+  if (pcb != NULL) {
+    struct packet_filter_event event;
+    err_t ret;
+
+    if (packet_filter_lock)
+      return ERR_OK;
+    else
+      packet_filter_lock = 1;
+
+    LWIP_ASSERT("invalid socket state for tcp_filter_dispatch_outgoing", pcb->state != LISTEN);
+    if (netif == NULL)
+      netif = netif_get_by_index(pcb->netif_idx);
+    event.reason = reason;
+    event.netif = netif;
+    event.pcb.tcp_pcb = pcb;
+    event.packet_hdr.tcp_hdr = NULL;
+    ret = filter_cb(filter_arg, &event, &pcb->local_ip, pcb->local_port, &pcb->remote_ip, pcb->remote_port);
+
+    packet_filter_lock = 0;
+
+    return ret;
+  } else
+    return ERR_OK;
+}
+#endif /* LWIP_PACKET_FILTER_API */
+
 #endif /* LWIP_TCP */
diff --git a/src/core/tcp_in.c b/src/core/tcp_in.c
index 1b17e40f..bd243a70 100644
--- a/src/core/tcp_in.c
+++ b/src/core/tcp_in.c
@@ -280,6 +280,16 @@ tcp_input(struct pbuf *p, struct netif *inp)
     prev = pcb;
   }
 
+#if LWIP_PACKET_FILTER_API
+  if (pcb != NULL) {
+    err = tcp_filter_dispatch_incoming(FILT_RECEIVING, NULL, ip_current_netif(), tcphdr);
+    if (err != ERR_OK) {
+      LWIP_DEBUGF(IP_DEBUG, ("tcp_input: tcp_filter_dispatch_incoming rejected packet.\n"));
+      goto dropped;
+    }
+  }
+#endif
+
   if (pcb == NULL) {
     /* If it did not go to an active connection, we check the connections
        in the TIME-WAIT state. */
@@ -445,6 +455,9 @@ tcp_input(struct pbuf *p, struct netif *inp)
            application that the connection is dead before we
            deallocate the PCB. */
         TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_RST);
+#if LWIP_PACKET_FILTER_API
+        (void)tcp_filter_dispatch_incoming(FILT_REMOTE_RESET, pcb, NULL /* force netif lookup */, tcphdr);
+#endif
         tcp_pcb_remove(&tcp_active_pcbs, pcb);
         tcp_free(pcb);
       } else {
@@ -569,6 +582,15 @@ aborted:
       pbuf_free(inseg.p);
       inseg.p = NULL;
     }
+#if LWIP_PACKET_FILTER_API
+  } else if (((err = tcp_filter_dispatch_incoming(FILT_PORT_UNREACHABLE, NULL /* pcb */, ip_data.current_input_netif, tcphdr)) != ERR_OK) &&
+             (err != ERR_RST))
+  {
+    LWIP_DEBUGF(IP_DEBUG, ("tcp_input: tcp_filter_dispatch_incoming rejected packet to unreachable port.\n"));
+    TCP_STATS_INC(tcp.proterr);
+    TCP_STATS_INC(tcp.drop);
+    pbuf_free(p);
+#endif
   } else {
     /* If no matching PCB was found, send a TCP RST (reset) to the
        sender. */
@@ -610,6 +632,9 @@ tcp_input_delayed_close(struct tcp_pcb *pcb)
           ensure the application doesn't continue using the PCB. */
       TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_CLSD);
     }
+#if LWIP_PACKET_FILTER_API
+    (void)tcp_filter_dispatch_incoming(FILT_CLOSED, pcb, NULL /* force netif lookup */, tcphdr);
+#endif
     tcp_pcb_remove(&tcp_active_pcbs, pcb);
     tcp_free(pcb);
     return 1;
@@ -640,6 +665,21 @@ tcp_listen_input(struct tcp_pcb_listen *pcb)
 
   LWIP_ASSERT("tcp_listen_input: invalid pcb", pcb != NULL);
 
+#if LWIP_PACKET_FILTER_API
+  {
+    err_t err = tcp_filter_dispatch_incoming(FILT_ACCEPTING, (struct tcp_pcb *)pcb, ip_data.current_input_netif, tcphdr);
+    if (err != ERR_OK) {
+      if (err == ERR_RST) {
+        LWIP_DEBUGF(IP_DEBUG, ("tcp_listen_input: tcp_filter_dispatch_incoming rejected connect, sending reset.\n"));
+        tcp_rst_netif(ip_data.current_input_netif, ackno, seqno + tcplen, ip_current_dest_addr(),
+                      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
+      } else
+        LWIP_DEBUGF(IP_DEBUG, ("tcp_listen_input: tcp_filter_dispatch_incoming rejected connect.\n"));
+      return;
+    }
+  }
+#endif
+
   /* In the LISTEN state, we check for incoming SYN segments,
      creates a new PCB, and responds with a SYN|ACK. */
   if (flags & TCP_ACK) {
@@ -668,6 +708,9 @@ tcp_listen_input(struct tcp_pcb_listen *pcb)
       LWIP_UNUSED_ARG(err); /* err not useful here */
       return;
     }
+#if LWIP_PACKET_FILTER_API
+    tcp_set_flags(npcb, TF_ACCEPTED);
+#endif
 #if TCP_LISTEN_BACKLOG
     pcb->accepts_pending++;
     tcp_set_flags(npcb, TF_BACKLOGPEND);
@@ -981,6 +1024,9 @@ tcp_process(struct tcp_pcb *pcb)
           if (recv_flags & TF_GOT_FIN) {
             tcp_ack_now(pcb);
             pcb->state = CLOSE_WAIT;
+#if LWIP_PACKET_FILTER_API
+            (void)tcp_filter_dispatch_incoming(FILT_CLOSE_WAIT, pcb, ip_data.current_input_netif, tcphdr);
+#endif
           }
         } else {
           /* incorrect ACK number, send RST */
@@ -996,6 +1042,9 @@ tcp_process(struct tcp_pcb *pcb)
       if (recv_flags & TF_GOT_FIN) { /* passive close */
         tcp_ack_now(pcb);
         pcb->state = CLOSE_WAIT;
+#if LWIP_PACKET_FILTER_API
+        (void)tcp_filter_dispatch_incoming(FILT_CLOSE_WAIT, pcb, ip_data.current_input_netif, tcphdr);
+#endif
       }
       break;
     case FIN_WAIT_1:
@@ -1606,6 +1655,9 @@ tcp_receive(struct tcp_pcb *pcb)
             recv_flags |= TF_GOT_FIN;
             if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
               pcb->state = CLOSE_WAIT;
+#if LWIP_PACKET_FILTER_API
+              (void)tcp_filter_dispatch_incoming(FILT_CLOSE_WAIT, pcb, ip_data.current_input_netif, tcphdr);
+#endif
             }
           }
 
diff --git a/src/core/tcp_out.c b/src/core/tcp_out.c
index cfcc55dd..73dfdd1a 100644
--- a/src/core/tcp_out.c
+++ b/src/core/tcp_out.c
@@ -1305,6 +1305,8 @@ tcp_output(struct tcp_pcb *pcb)
     ip_addr_copy(pcb->local_ip, *local_ip);
   }
 
+  TCP_FILTER_ASSERT_OUTGOING(FILT_SENDING, pcb, netif);
+
   /* Handle the current segment not fitting within the window */
   if (lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd) {
     /* We need to start the persistent timer when the next unsent segment does not fit
diff --git a/src/core/udp.c b/src/core/udp.c
index c787ae0a..75c675f9 100644
--- a/src/core/udp.c
+++ b/src/core/udp.c
@@ -363,6 +363,33 @@ udp_input(struct pbuf *p, struct netif *inp)
       }
     }
 #endif /* CHECKSUM_CHECK_UDP */
+
+#if LWIP_PACKET_FILTER_API
+    if (pcb == NULL) {
+      err_t err = udp_filter_dispatch_incoming(FILT_PORT_UNREACHABLE, pcb, ip_current_netif(), udphdr);
+      if (err != ERR_OK) {
+        LWIP_DEBUGF(IP_DEBUG, ("udp_input: udp_filter_dispatch_incoming rejected packet.\n"));
+        if (err == ERR_RST)
+          icmp_port_unreach(ip_current_is_v6(), p);
+        UDP_STATS_INC(udp.proterr);
+        UDP_STATS_INC(udp.drop);
+        MIB2_STATS_INC(mib2.udpnoports);
+        pbuf_free(p);
+        goto end;
+      }
+    } else {
+      err_t err = udp_filter_dispatch_incoming(FILT_RECEIVING, pcb, ip_current_netif(), udphdr);
+      if (err != ERR_OK) {
+        LWIP_DEBUGF(IP_DEBUG, ("udp_input: udp_filter_dispatch_incoming rejected packet.\n"));
+        if (err == ERR_RST)
+          icmp_port_unreach(ip_current_is_v6(), p);
+        UDP_STATS_INC(udp.drop);
+        pbuf_free(p);
+        goto end;
+      }
+    }
+#endif
+
     if (pbuf_remove_header(p, UDP_HLEN)) {
       /* Can we cope with this failing? Just assert for now */
       LWIP_ASSERT("pbuf_remove_header failed", 0);
@@ -409,7 +436,6 @@ udp_input(struct pbuf *p, struct netif *inp)
       }
     } else {
       LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));
-
 #if LWIP_ICMP || LWIP_ICMP6
       /* No match was found, send ICMP destination port unreachable unless
          destination address was broadcast/multicast. */
@@ -751,6 +777,11 @@ udp_sendto_if_src_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *d
       return err;
     }
   }
+#if LWIP_PACKET_FILTER_API
+  else {
+    UDP_FILTER_ASSERT_OUTGOING(FILT_SENDING, pcb, NULL, src_ip, pcb->local_port, dst_ip, dst_port);
+  }
+#endif
 
   /* packet too large to add a UDP header without causing an overflow? */
   if ((u16_t)(p->tot_len + UDP_HLEN) < p->tot_len) {
@@ -1017,6 +1048,9 @@ udp_bind(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
   ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
 
   pcb->local_port = port;
+
+  UDP_FILTER_ASSERT_INCOMING(FILT_BINDING, pcb, NULL, NULL);
+
   mib2_udp_bind(pcb);
   /* pcb not active yet? */
   if (rebind == 0) {
@@ -1101,6 +1135,8 @@ udp_connect(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
   pcb->remote_port = port;
   pcb->flags |= UDP_FLAGS_CONNECTED;
 
+  UDP_FILTER_ASSERT_OUTGOING(FILT_CONNECTING, pcb, NULL, &pcb->local_ip, pcb->local_port, ipaddr, port);
+
   LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("udp_connect: connected to "));
   ip_addr_debug_print_val(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                           pcb->remote_ip);
@@ -1133,6 +1169,13 @@ udp_disconnect(struct udp_pcb *pcb)
 
   LWIP_ERROR("udp_disconnect: invalid pcb", pcb != NULL, return);
 
+  /* mark PCB as unconnected */
+  udp_clear_flags(pcb, UDP_FLAGS_CONNECTED);
+
+#if LWIP_PACKET_FILTER_API
+  (void)udp_filter_dispatch_outgoing(FILT_DISSOCIATE, pcb, NULL, &pcb->local_ip, pcb->local_port, &pcb->remote_ip, pcb->remote_port);
+#endif
+
   /* reset remote address association */
 #if LWIP_IPV4 && LWIP_IPV6
   if (IP_IS_ANY_TYPE_VAL(pcb->local_ip)) {
@@ -1143,10 +1186,9 @@ udp_disconnect(struct udp_pcb *pcb)
 #if LWIP_IPV4 && LWIP_IPV6
   }
 #endif
+
   pcb->remote_port = 0;
   pcb->netif_idx = NETIF_NO_INDEX;
-  /* mark PCB as unconnected */
-  udp_clear_flags(pcb, UDP_FLAGS_CONNECTED);
 }
 
 /**
@@ -1188,6 +1230,10 @@ udp_remove(struct udp_pcb *pcb)
 
   LWIP_ERROR("udp_remove: invalid pcb", pcb != NULL, return);
 
+#if LWIP_PACKET_FILTER_API
+  (void)udp_filter_dispatch_outgoing(FILT_CLOSED, pcb, NULL, &pcb->local_ip, pcb->local_port, &pcb->remote_ip, pcb->remote_port);
+#endif
+
   mib2_udp_unbind(pcb);
   /* pcb to be removed is first in list? */
   if (udp_pcbs == pcb) {
@@ -1318,4 +1364,91 @@ udp_debug_print(struct udp_hdr *udphdr)
 }
 #endif /* UDP_DEBUG */
 
+#if LWIP_PACKET_FILTER_API
+
+static void *filter_arg = 0;
+static udp_filter_fn filter_cb = NULL;
+static packet_filter_event_mask_t filter_reason_mask = 0;
+
+void
+udp_filter_arg(void *arg)
+{
+  filter_arg = arg;
+}
+
+void
+udp_filter_mask(packet_filter_event_mask_t mask)
+{
+  filter_reason_mask = mask;
+}
+
+void udp_filter(udp_filter_fn filter) {
+  filter_cb = filter;
+}
+
+err_t udp_filter_dispatch_incoming(packet_filter_event_t reason, struct udp_pcb *pcb, const struct netif *netif, const struct udp_hdr *hdr) {
+  struct packet_filter_event event;
+  err_t ret;
+
+  if (! ((1U << reason) & filter_reason_mask))
+    return ERR_OK;
+  if (filter_cb == NULL)
+    return ERR_OK;
+  LWIP_ASSERT_CORE_LOCKED();
+
+  if (packet_filter_lock)
+    return ERR_OK;
+  else
+    packet_filter_lock = 1;
+
+  if ((netif == NULL) && (pcb != NULL))
+    netif = netif_get_by_index(pcb->netif_idx);
+  event.reason = reason;
+  event.netif = netif;
+  event.pcb.udp_pcb = pcb;
+  event.packet_hdr.udp_hdr = hdr;
+  if (hdr != NULL) {
+    ret = filter_cb(filter_arg, &event,
+                    ip_current_dest_addr(), lwip_ntohs(hdr->dest), ip_current_src_addr(), lwip_ntohs(hdr->src));
+  } else if (pcb != NULL) {
+    ret = filter_cb(filter_arg, &event,
+                    &pcb->local_ip, pcb->local_port, NULL /* raddr */, 0 /* remote_port */);
+  } else
+    ret = ERR_OK;
+
+  packet_filter_lock = 0;
+
+  return ret;
+}
+
+err_t udp_filter_dispatch_outgoing(packet_filter_event_t reason, struct udp_pcb *pcb, const struct netif *netif, const ip_addr_t *laddr, u16_t lport, const ip_addr_t *raddr, u16_t rport) {
+  struct packet_filter_event event;
+  err_t ret;
+
+  if (! ((1U << reason) & filter_reason_mask))
+    return ERR_OK;
+  if (filter_cb == NULL)
+    return ERR_OK;
+  LWIP_ASSERT_CORE_LOCKED();
+
+  if (packet_filter_lock)
+    return ERR_OK;
+  else
+    packet_filter_lock = 1;
+
+  if ((netif == NULL) && (pcb != NULL))
+    netif = netif_get_by_index(pcb->netif_idx);
+  event.reason = reason;
+  event.netif = netif;
+  event.pcb.udp_pcb = pcb;
+  event.packet_hdr.udp_hdr = NULL;
+  ret = filter_cb(filter_arg, &event, laddr, lport, raddr, rport);
+
+  packet_filter_lock = 0;
+
+  return ret;
+}
+
+#endif /* LWIP_PACKET_FILTER_API */
+
 #endif /* LWIP_UDP */
diff --git a/src/include/lwip/filter.h b/src/include/lwip/filter.h
new file mode 100644
index 00000000..c0757496
--- /dev/null
+++ b/src/include/lwip/filter.h
@@ -0,0 +1,99 @@
+/*
+ * lwip/src/include/lwip/filter.h
+ *
+ * Copyright (c) 2021-2023 wolfSSL Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of wolfSentry.
+ *
+ * Author: Daniel Pouzzner <douzzer@wolfssl.com>
+ *
+ */
+
+#ifndef LWIP_HDR_FILTER_H
+#define LWIP_HDR_FILTER_H
+
+typedef enum packet_filter_events {
+    FILT_BINDING = 0,
+    FILT_DISSOCIATE = 1,
+    FILT_LISTENING = 2,
+    FILT_STOP_LISTENING = 3,
+    FILT_CONNECTING = 4,
+    FILT_ACCEPTING = 5,
+    FILT_CLOSED = 6,
+    FILT_REMOTE_RESET = 7,
+    FILT_RECEIVING = 8,
+    FILT_SENDING = 9,
+    FILT_ADDR_UNREACHABLE = 10,
+    FILT_PORT_UNREACHABLE = 11,
+    FILT_INBOUND_ERR = 12,
+    FILT_OUTBOUND_ERR = 13,
+    FILT_CLOSE_WAIT = 14
+} packet_filter_event_t;
+
+typedef u16_t packet_filter_event_mask_t;
+
+#define FILT_MASK(x) (((u16_t)1) << FILT_ ## x)
+
+struct packet_filter_event {
+    packet_filter_event_t reason;
+    const struct netif *netif;
+    union {
+        const struct pbuf *raw_p;
+#if LWIP_TCP
+        struct tcp_pcb *tcp_pcb;
+#endif
+#if LWIP_UDP
+        struct udp_pcb *udp_pcb;
+#endif
+    } pcb;
+    union {
+#if LWIP_ARP || LWIP_ETHERNET
+        const struct eth_hdr *eth_hdr;
+#endif
+#if LWIP_IPV4
+        const struct ip_hdr *ip4_hdr;
+#endif
+#if LWIP_IPV6
+        const struct ip6_hdr *ip6_hdr;
+#endif
+#if LWIP_TCP
+        const struct tcp_hdr *tcp_hdr;
+#endif
+#if LWIP_UDP
+        const struct udp_hdr *udp_hdr;
+#endif
+#if LWIP_IPV4 && LWIP_ICMP
+        const struct icmp_hdr *icmp_hdr;
+#endif
+#if LWIP_IPV6 && LWIP_ICMP
+        const struct icmp6_hdr *icmp6_hdr;
+#endif
+    } packet_hdr;
+};
+
+extern int packet_filter_lock;
+
+#endif /* LWIP_HDR_FILTER_H */
diff --git a/src/include/lwip/icmp.h b/src/include/lwip/icmp.h
index f5a31fd4..b7f3608b 100644
--- a/src/include/lwip/icmp.h
+++ b/src/include/lwip/icmp.h
@@ -42,6 +42,10 @@
 #include "lwip/ip_addr.h"
 #include "lwip/netif.h"
 #include "lwip/prot/icmp.h"
+#if LWIP_PACKET_FILTER_API
+#include "lwip/filter.h"
+#include "lwip/prot/ip4.h"
+#endif
 
 #if LWIP_IPV6 && LWIP_ICMP6
 #include "lwip/icmp6.h"
@@ -81,6 +85,19 @@ void icmp_input(struct pbuf *p, struct netif *inp);
 void icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t);
 void icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t);
 
+#if LWIP_PACKET_FILTER_API
+
+struct icmp_hdr;
+typedef err_t (*icmp_filter_fn)(void *arg, struct packet_filter_event *event, const ip4_addr_t *laddr, const ip4_addr_t *raddr, u8_t icmp4_type);
+
+void icmp_filter(icmp_filter_fn filter_incoming);
+void icmp_filter_mask(packet_filter_event_mask_t mask);
+void icmp_filter_arg(void *arg);
+err_t icmp_filter_dispatch_incoming(packet_filter_event_t reason, const struct netif *netif, const struct icmp_hdr *hdr);
+err_t icmp_filter_dispatch_outgoing(packet_filter_event_t reason, const struct netif *netif, const ip4_addr_p_t *laddr, const ip4_addr_p_t *raddr, u8_t icmp4_type, const struct icmp_hdr *hdr);
+
+#endif /* LWIP_PACKET_FILTER_API */
+
 #endif /* LWIP_IPV4 && LWIP_ICMP */
 
 #if LWIP_IPV4 && LWIP_IPV6
diff --git a/src/include/lwip/icmp6.h b/src/include/lwip/icmp6.h
index 0ccb7899..d3cb12ac 100644
--- a/src/include/lwip/icmp6.h
+++ b/src/include/lwip/icmp6.h
@@ -46,6 +46,10 @@
 #include "lwip/ip6_addr.h"
 #include "lwip/netif.h"
 #include "lwip/prot/icmp6.h"
+#if LWIP_PACKET_FILTER_API
+#include "lwip/filter.h"
+#include "lwip/prot/ip6.h"
+#endif
 
 #ifdef __cplusplus
 extern "C" {
@@ -61,8 +65,20 @@ void icmp6_time_exceeded_with_addrs(struct pbuf *p, enum icmp6_te_code c,
     const ip6_addr_t *src_addr, const ip6_addr_t *dest_addr);
 void icmp6_param_problem(struct pbuf *p, enum icmp6_pp_code c, const void *pointer);
 
-#endif /* LWIP_ICMP6 && LWIP_IPV6 */
+#if LWIP_PACKET_FILTER_API
+
+struct icmp6_hdr;
+typedef err_t (*icmp6_filter_fn)(void *arg, struct packet_filter_event *event, const ip6_addr_t *laddr, const ip6_addr_t *raddr, u8_t icmp6_type);
 
+void icmp6_filter(icmp6_filter_fn filter_incoming);
+void icmp6_filter_mask(packet_filter_event_mask_t mask);
+void icmp6_filter_arg(void *arg);
+err_t icmp6_filter_dispatch_incoming(packet_filter_event_t reason, const struct netif *netif, const struct icmp6_hdr *hdr);
+err_t icmp6_filter_dispatch_outgoing(packet_filter_event_t reason, const struct netif *netif, const ip6_addr_t *laddr, const ip6_addr_t *raddr, u8_t icmp6_type, const struct icmp6_hdr *hdr);
+
+#endif /* LWIP_PACKET_FILTER_API */
+
+#endif /* LWIP_ICMP6 && LWIP_IPV6 */
 
 #ifdef __cplusplus
 }
diff --git a/src/include/lwip/ip4.h b/src/include/lwip/ip4.h
index 4d7228d0..07f94c69 100644
--- a/src/include/lwip/ip4.h
+++ b/src/include/lwip/ip4.h
@@ -47,6 +47,9 @@
 #include "lwip/err.h"
 #include "lwip/netif.h"
 #include "lwip/prot/ip4.h"
+#if LWIP_PACKET_FILTER_API
+#include "lwip/filter.h"
+#endif
 
 #ifdef __cplusplus
 extern "C" {
@@ -100,6 +103,19 @@ void ip4_debug_print(struct pbuf *p);
 #define ip4_debug_print(p)
 #endif /* IP_DEBUG */
 
+#if LWIP_PACKET_FILTER_API
+
+struct ip4_hdr;
+typedef err_t (*ip4_filter_fn)(void *arg, struct packet_filter_event *event, const ip4_addr_t *laddr, const ip4_addr_t *raddr, u8_t proto);
+
+void ip4_filter(ip4_filter_fn filter_incoming);
+void ip4_filter_mask(packet_filter_event_mask_t mask);
+void ip4_filter_arg(void *arg);
+err_t ip4_filter_dispatch_incoming(packet_filter_event_t reason, const struct netif *netif, const struct pbuf *p);
+err_t ip4_filter_dispatch_outgoing(packet_filter_event_t reason, const struct netif *netif, const ip4_addr_t *src, const ip4_addr_t *dest, const struct pbuf *p);
+
+#endif /* LWIP_PACKET_FILTER_API */
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/include/lwip/ip6.h b/src/include/lwip/ip6.h
index f894e063..b857029d 100644
--- a/src/include/lwip/ip6.h
+++ b/src/include/lwip/ip6.h
@@ -50,8 +50,10 @@
 #include "lwip/def.h"
 #include "lwip/pbuf.h"
 #include "lwip/netif.h"
-
 #include "lwip/err.h"
+#if LWIP_PACKET_FILTER_API
+#include "lwip/filter.h"
+#endif
 
 #ifdef __cplusplus
 extern "C" {
@@ -83,6 +85,18 @@ void ip6_debug_print(struct pbuf *p);
 #define ip6_debug_print(p)
 #endif /* IP6_DEBUG */
 
+#if LWIP_PACKET_FILTER_API
+
+struct ip6_hdr;
+typedef err_t (*ip6_filter_fn)(void *arg, struct packet_filter_event *event, const ip6_addr_t *laddr, const ip6_addr_t *raddr, u8_t proto);
+
+void ip6_filter(ip6_filter_fn filter_incoming);
+void ip6_filter_mask(packet_filter_event_mask_t mask);
+void ip6_filter_arg(void *arg);
+err_t ip6_filter_dispatch_incoming(packet_filter_event_t reason, const struct netif *netif, const struct pbuf *p);
+err_t ip6_filter_dispatch_outgoing(packet_filter_event_t reason, const struct netif *netif, const ip6_addr_t *src, const ip6_addr_t *dest, const struct pbuf *p);
+
+#endif /* LWIP_PACKET_FILTER_API */
 
 #ifdef __cplusplus
 }
diff --git a/src/include/lwip/opt.h b/src/include/lwip/opt.h
index 2573285f..347d1764 100644
--- a/src/include/lwip/opt.h
+++ b/src/include/lwip/opt.h
@@ -3622,4 +3622,14 @@
  * @}
  */
 
+
+/*
+   --------------------------------------------------
+   ------------- Packet filter support --------------
+   --------------------------------------------------
+*/
+#ifndef LWIP_PACKET_FILTER_API
+#define LWIP_PACKET_FILTER_API 0
+#endif
+
 #endif /* LWIP_HDR_OPT_H */
diff --git a/src/include/lwip/tcp.h b/src/include/lwip/tcp.h
index 3991fd6e..3d4df334 100644
--- a/src/include/lwip/tcp.h
+++ b/src/include/lwip/tcp.h
@@ -50,6 +50,9 @@
 #include "lwip/err.h"
 #include "lwip/ip6.h"
 #include "lwip/ip6_addr.h"
+#if LWIP_PACKET_FILTER_API
+#include "lwip/filter.h"
+#endif
 
 #ifdef __cplusplus
 extern "C" {
@@ -269,6 +272,9 @@ struct tcp_pcb {
 #define TF_RTO         0x0800U /* RTO timer has fired, in-flight data moved to unsent and being retransmitted */
 #if LWIP_TCP_SACK_OUT
 #define TF_SACK        0x1000U /* Selective ACKs enabled */
+#endif
+#ifdef LWIP_PACKET_FILTER_API
+#define TF_ACCEPTED    0x2000U /* Connection was accepted (was remote-initiated) */
 #endif
 
   /* the rest of the fields are in host byte order
@@ -491,6 +497,29 @@ void tcp_ext_arg_set(struct tcp_pcb *pcb, u8_t id, void *arg);
 void *tcp_ext_arg_get(const struct tcp_pcb *pcb, u8_t id);
 #endif
 
+#if LWIP_PACKET_FILTER_API
+
+/* note, tcp_hdr is null except for reasons FILT_ACCEPTING, FILT_RECEIVING,
+ * FILT_REMOTE_RESET, FILT_PORT_UNREACHABLE, and sometimes FILT_CLOSED.
+ */
+struct tcp_hdr;
+typedef err_t (*tcp_filter_fn)(void *arg, struct packet_filter_event *event, ip_addr_t *laddr, u16_t lport, ip_addr_t *raddr, u16_t rport);
+
+void tcp_filter(tcp_filter_fn cb);
+void tcp_filter_mask(packet_filter_event_mask_t mask);
+void tcp_filter_arg(void *arg);
+err_t tcp_filter_dispatch_incoming(packet_filter_event_t reason, struct tcp_pcb *pcb, struct netif *netif, struct tcp_hdr *hdr);
+#define TCP_FILTER_ASSERT_INCOMING(reason, pcb, netif, hdr) do { err_t __ret = tcp_filter_dispatch_incoming(reason, pcb, netif, hdr); if (__ret != 0) { LWIP_DEBUGF(IP_DEBUG, ("tcp_filter_dispatch_incoming rejected packet.\n")); return __ret; }} while (0)
+err_t tcp_filter_dispatch_outgoing(packet_filter_event_t reason, struct tcp_pcb *pcb, struct netif *netif);
+#define TCP_FILTER_ASSERT_OUTGOING(reason, pcb, netif) do { err_t __ret = tcp_filter_dispatch_outgoing(reason, pcb, netif); if (__ret != 0) { LWIP_DEBUGF(IP_DEBUG, ("tcp_filter_dispatch_outgoing rejected packet.\n")); return __ret; }} while (0)
+
+#else /* !LWIP_PACKET_FILTER_API */
+
+#define TCP_FILTER_ASSERT_INCOMING(reason, pcb, netif, hdr) do {} while (0);
+#define TCP_FILTER_ASSERT_OUTGOING(reason, pcb, netif) do {} while (0);
+
+#endif /* LWIP_PACKET_FILTER_API */
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/include/lwip/tcpbase.h b/src/include/lwip/tcpbase.h
index 018790f1..37fe0ff2 100644
--- a/src/include/lwip/tcpbase.h
+++ b/src/include/lwip/tcpbase.h
@@ -69,6 +69,12 @@ enum tcp_state {
 /* ATTENTION: this depends on state number ordering! */
 #define TCP_STATE_IS_CLOSING(state) ((state) >= FIN_WAIT_1)
 
+#ifdef LWIP_PACKET_FILTER_API
+typedef u16_t tcp_state_mask_t;
+#define TCP_STATE_BIT(x) (((u_16_t)1) << ((u_16_t)(x)))
+#define TCP_STATE_BIT_ALL (~((u_16_t)0))
+#endif
+
 /* Flags for "apiflags" parameter in tcp_write */
 #define TCP_WRITE_FLAG_COPY 0x01
 #define TCP_WRITE_FLAG_MORE 0x02
diff --git a/src/include/lwip/udp.h b/src/include/lwip/udp.h
index f1deae3e..46a123a4 100644
--- a/src/include/lwip/udp.h
+++ b/src/include/lwip/udp.h
@@ -48,6 +48,9 @@
 #include "lwip/ip.h"
 #include "lwip/ip6_addr.h"
 #include "lwip/prot/udp.h"
+#if LWIP_PACKET_FILTER_API
+#include "lwip/filter.h"
+#endif
 
 #ifdef __cplusplus
 extern "C" {
@@ -186,6 +189,29 @@ void udp_debug_print(struct udp_hdr *udphdr);
 
 void udp_netif_ip_addr_changed(const ip_addr_t* old_addr, const ip_addr_t* new_addr);
 
+#if LWIP_PACKET_FILTER_API
+
+/* note, these callbacks are used by udp_bind() to impose
+ * policies before any traffic can move, in which case udp_hdr will be null.
+ */
+struct udp_hdr;
+typedef err_t (*udp_filter_fn)(void *arg, struct packet_filter_event *event, const ip_addr_t *laddr, u16_t lport, const ip_addr_t *raddr, u16_t rport);
+
+void udp_filter(udp_filter_fn filter_incoming);
+void udp_filter_mask(packet_filter_event_mask_t mask);
+void udp_filter_arg(void *arg);
+err_t udp_filter_dispatch_incoming(packet_filter_event_t reason, struct udp_pcb *pcb, const struct netif *netif, const struct udp_hdr *hdr);
+#define UDP_FILTER_ASSERT_INCOMING(reason, pcb, netif, hdr) do { err_t __ret = udp_filter_dispatch_incoming(reason, pcb, netif, hdr); if (__ret != 0) { LWIP_DEBUGF(IP_DEBUG, ("udp_filter_dispatch_incoming rejected packet.\n")); return __ret; }} while (0)
+err_t udp_filter_dispatch_outgoing(packet_filter_event_t reason, struct udp_pcb *pcb, const struct netif *netif, const ip_addr_t *laddr, u16_t lport, const ip_addr_t *raddr, u16_t rport);
+#define UDP_FILTER_ASSERT_OUTGOING(reason, pcb, netif, laddr, lport, raddr, rport) do { err_t __ret = udp_filter_dispatch_outgoing(reason, pcb, netif, laddr, lport, raddr, rport); if (__ret != 0) { LWIP_DEBUGF(IP_DEBUG, ("udp_filter_dispatch_outgoing rejected packet.\n")); return __ret; }} while (0)
+
+#else /* !LWIP_PACKET_FILTER_API */
+
+#define UDP_FILTER_ASSERT_INCOMING(reason, pcb, netif, hdr) do {} while (0);
+#define UDP_FILTER_ASSERT_OUTGOING(reason, pcb, netif, laddr, lport, raddr, rport) do {} while (0);
+
+#endif /* LWIP_PACKET_FILTER_API */
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/include/netif/ethernet.h b/src/include/netif/ethernet.h
index 49649cbf..9e7999a9 100644
--- a/src/include/netif/ethernet.h
+++ b/src/include/netif/ethernet.h
@@ -46,6 +46,9 @@
 #include "lwip/pbuf.h"
 #include "lwip/netif.h"
 #include "lwip/prot/ethernet.h"
+#if LWIP_PACKET_FILTER_API
+#include "lwip/filter.h"
+#endif
 
 #ifdef __cplusplus
 extern "C" {
@@ -68,6 +71,21 @@ err_t ethernet_output(struct netif* netif, struct pbuf* p, const struct eth_addr
 
 extern const struct eth_addr ethbroadcast, ethzero;
 
+#if LWIP_PACKET_FILTER_API
+
+/* note, these callbacks are used by udp_bind() to impose
+ * policies before any traffic can move, in which case udp_hdr will be null.
+ */
+typedef err_t (*ethernet_filter_fn)(void *arg, struct packet_filter_event *event, const struct eth_addr *laddr, const struct eth_addr *raddr, u16_t type);
+
+void ethernet_filter(ethernet_filter_fn filter_incoming);
+void ethernet_filter_mask(packet_filter_event_mask_t mask);
+void ethernet_filter_arg(void *arg);
+err_t ethernet_filter_dispatch_incoming(packet_filter_event_t reason, const struct netif *netif, const struct eth_hdr *hdr, u16_t type, const struct pbuf *p);
+err_t ethernet_filter_dispatch_outgoing(packet_filter_event_t reason, const struct netif *netif, const struct eth_addr *src, const struct eth_addr *dst, u16_t eth_type, const struct pbuf *p);
+
+#endif /* LWIP_PACKET_FILTER_API */
+
 #endif /* LWIP_ARP || LWIP_ETHERNET */
 
 #ifdef __cplusplus
diff --git a/src/netif/ethernet.c b/src/netif/ethernet.c
index db5c514b..90f7dfbd 100644
--- a/src/netif/ethernet.c
+++ b/src/netif/ethernet.c
@@ -167,6 +167,11 @@ ethernet_input(struct pbuf *p, struct netif *netif)
     }
   }
 
+#if LWIP_PACKET_FILTER_API
+  if (ethernet_filter_dispatch_incoming(FILT_RECEIVING, netif, ethhdr, type, p) != ERR_OK)
+    goto free_and_return;
+#endif
+
   switch (type) {
 #if LWIP_IPV4 && LWIP_ARP
     /* IP packet? */
@@ -306,6 +311,14 @@ ethernet_output(struct netif * netif, struct pbuf * p,
 
   LWIP_ASSERT_CORE_LOCKED();
 
+#if LWIP_PACKET_FILTER_API
+  {
+    err_t ret = ethernet_filter_dispatch_outgoing(FILT_SENDING, netif, src, dst, eth_type, p);
+    if (ret != ERR_OK)
+      return ret;
+  }
+#endif
+
   ethhdr = (struct eth_hdr *)p->payload;
   ethhdr->type = eth_type_be;
   SMEMCPY(&ethhdr->dest, dst, ETH_HWADDR_LEN);
@@ -326,4 +339,86 @@ pbuf_header_failed:
   return ERR_BUF;
 }
 
+
+#if LWIP_PACKET_FILTER_API
+
+static void *filter_arg = 0;
+static ethernet_filter_fn filter_cb = NULL;
+static packet_filter_event_mask_t filter_reason_mask = 0;
+
+void
+ethernet_filter_arg(void *arg)
+{
+  filter_arg = arg;
+}
+
+void
+ethernet_filter_mask(packet_filter_event_mask_t mask)
+{
+  filter_reason_mask = mask;
+}
+
+void ethernet_filter(ethernet_filter_fn filter) {
+  filter_cb = filter;
+}
+
+err_t ethernet_filter_dispatch_incoming(packet_filter_event_t reason, const struct netif *netif, const struct eth_hdr *hdr, u16_t type, const struct pbuf *p) {
+  struct packet_filter_event event;
+  err_t ret;
+
+  if (! ((1U << reason) & filter_reason_mask))
+    return ERR_OK;
+  if (filter_cb == NULL)
+    return ERR_OK;
+  if (reason >= (sizeof(packet_filter_event_t) * 8))
+    return ERR_OK;
+  LWIP_ASSERT_CORE_LOCKED();
+
+  if (packet_filter_lock)
+    return ERR_OK;
+  else
+    packet_filter_lock = 1;
+
+  event.reason = reason;
+  event.netif = netif;
+  event.pcb.raw_p = p;
+  event.packet_hdr.eth_hdr = hdr;
+  ret = filter_cb(filter_arg, &event, &hdr->dest, &hdr->src, lwip_ntohs(type));
+
+  packet_filter_lock = 0;
+
+  return ret;
+}
+
+err_t ethernet_filter_dispatch_outgoing(packet_filter_event_t reason, const struct netif *netif, const struct eth_addr *src, const struct eth_addr *dst, u16_t type, const struct pbuf *p) {
+  struct packet_filter_event event;
+  err_t ret;
+
+  if (! ((1U << reason) & filter_reason_mask))
+    return ERR_OK;
+  if (filter_cb == NULL)
+    return ERR_OK;
+  if (reason >= (sizeof(packet_filter_event_t) * 8))
+    return ERR_OK;
+  LWIP_ASSERT_CORE_LOCKED();
+
+  if (packet_filter_lock)
+    return ERR_OK;
+  else
+    packet_filter_lock = 1;
+
+  event.reason = reason;
+  event.netif = netif;
+  event.pcb.raw_p = p;
+  event.packet_hdr.eth_hdr = NULL;
+  ret = filter_cb(filter_arg, &event, src, dst, type);
+
+  packet_filter_lock = 0;
+
+  return ret;
+}
+#endif
+
+
+
 #endif /* LWIP_ARP || LWIP_ETHERNET */
